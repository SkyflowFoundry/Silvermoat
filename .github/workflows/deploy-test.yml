name: Deploy Test Stack

on:
  pull_request:
    branches: [main]
    paths:
      - 'cdk/**'
      - 'lambda/**'
      - 'ui/**'
      - 'tests/**'
      - 'scripts/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number for stack naming (optional)'
        required: false
      force_deploy:
        description: 'Force stack deployment even if no changes detected'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

permissions:
  id-token: write
  contents: read
  pull-requests: read

jobs:
  detect-changes:
    name: Detect Changed Files
    runs-on: ubuntu-latest
    outputs:
      infrastructure_changed: ${{ steps.filter.outputs.infrastructure }}
      ui_changed: ${{ steps.filter.outputs.ui }}
      tests_changed: ${{ steps.filter.outputs.tests }}
      stack_exists: ${{ steps.check-stack.outputs.stack_exists }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Detect file changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infrastructure:
              - 'cdk/**'
              - 'lambda/**'
              - 'scripts/deploy-stack.sh'
            ui:
              - 'ui/**'
            tests:
              - 'tests/**'
              - '.github/workflows/deploy-test.yml'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Check if test stack exists
        id: check-stack
        run: |
          # Determine stack name (same logic as setup-stack)
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            STACK_NAME="silvermoat-test-pr-${{ github.event.pull_request.number }}"
          elif [ -n "${{ inputs.pr_number }}" ]; then
            STACK_NAME="silvermoat-test-pr-${{ inputs.pr_number }}"
          else
            STACK_NAME="silvermoat-test-${{ github.run_id }}"
          fi

          # Check if stack exists
          if aws cloudformation describe-stacks --stack-name "${STACK_NAME}" >/dev/null 2>&1; then
            echo "stack_exists=true" >> $GITHUB_OUTPUT
            echo "âœ… Stack ${STACK_NAME} exists"
          else
            echo "stack_exists=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ Stack ${STACK_NAME} does not exist (first run)"
          fi

  deploy-stack:
    name: Deploy Stack
    needs: [detect-changes]
    if: |
      needs.detect-changes.outputs.infrastructure_changed == 'true' ||
      needs.detect-changes.outputs.stack_exists == 'false' ||
      inputs.force_deploy == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 25

    outputs:
      stack_name: ${{ steps.stack-name.outputs.stack_name }}
      stack_status: ${{ steps.check-stack.outputs.stack_status }}
      stack_deleted: ${{ steps.check-stack.outputs.stack_deleted }}
      skip_deploy: ${{ steps.check-deployment.outputs.skip_deploy || 'false' }}
      skip_reason: ${{ steps.check-deployment.outputs.skip_reason || '' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-env

      - name: Install dependencies
        uses: ./.github/actions/install-deps

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Determine test stack name
        id: stack-name
        run: |
          if [ -n "${{ github.event.pull_request.number }}" ]; then
            STACK_NAME="silvermoat-test-pr-${{ github.event.pull_request.number }}"
          elif [ -n "${{ inputs.pr_number }}" ]; then
            STACK_NAME="silvermoat-test-pr-${{ inputs.pr_number }}"
          else
            STACK_NAME="silvermoat-test-${{ github.run_id }}"
          fi
          echo "stack_name=${STACK_NAME}" >> $GITHUB_OUTPUT
          echo "Test stack name: ${STACK_NAME}"

      - name: Check if stack exists
        id: check-stack
        run: |
          STACK_NAME="${{ steps.stack-name.outputs.stack_name }}"
          echo "Checking if stack ${STACK_NAME} exists..."

          # Check stack status
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")

          echo "Stack status: ${STACK_STATUS}"
          echo "stack_status=${STACK_STATUS}" >> $GITHUB_OUTPUT

          # Handle failed rollback states - delete stack before redeploying
          if [[ "${STACK_STATUS}" == "ROLLBACK_COMPLETE" ]] || \
             [[ "${STACK_STATUS}" == "ROLLBACK_FAILED" ]] || \
             [[ "${STACK_STATUS}" == "UPDATE_ROLLBACK_COMPLETE" ]] || \
             [[ "${STACK_STATUS}" == "UPDATE_ROLLBACK_FAILED" ]]; then
            echo "ðŸ—‘ï¸ Stack in failed state (${STACK_STATUS}), deleting before redeployment..."
            cd cdk
            cdk destroy "${STACK_NAME}" --force || true
            echo "âœ… Stack deleted"
            echo "stack_deleted=true" >> $GITHUB_OUTPUT
          elif [[ "${STACK_STATUS}" == "NOT_FOUND" ]]; then
            echo "Stack does not exist, will create"
            echo "stack_deleted=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Stack exists (${STACK_STATUS})"
            echo "stack_deleted=false" >> $GITHUB_OUTPUT
          fi

      - name: Setup AWS CDK
        uses: ./.github/actions/setup-aws-cdk

      - name: Check if infrastructure changes require deployment
        id: check-deployment
        if: |
          needs.detect-changes.outputs.infrastructure_changed != 'true' &&
          steps.check-stack.outputs.stack_status != 'NOT_FOUND' &&
          inputs.force_deploy != 'true'
        run: |
          echo "No infrastructure file changes detected. Checking CDK diff..."

          cd cdk

          # Run cdk diff to check for actual changes
          if cdk diff "${{ steps.stack-name.outputs.stack_name }}" > /tmp/cdk-diff.txt 2>&1; then
            DIFF_EXIT=$?

            if [ $DIFF_EXIT -eq 0 ]; then
              echo "âœ“ CDK diff shows no changes - deployment can be skipped"
              echo "skip_deploy=true" >> $GITHUB_OUTPUT
              echo "skip_reason=No infrastructure changes detected" >> $GITHUB_OUTPUT
            else
              echo "âš  CDK diff detected changes despite no file changes (possibly parameter updates)"
              echo "skip_deploy=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš  CDK diff failed - will deploy to be safe"
            echo "skip_deploy=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate CDK stacks (synth)
        if: |
          needs.detect-changes.outputs.infrastructure_changed == 'true' ||
          steps.check-stack.outputs.stack_status == 'NOT_FOUND'
        env:
          STACK_NAME: ${{ steps.stack-name.outputs.stack_name }}
          STAGE_NAME: test
          CREATE_CLOUDFRONT: "false"
          DOMAIN_NAME: ""
        run: |
          echo "Validating CDK stacks via synthesis..."
          cd cdk
          cdk synth ${{ steps.stack-name.outputs.stack_name }} > /dev/null
          echo "âœ… CDK stack synthesis successful"

      - name: Bootstrap CDK
        if: steps.check-deployment.outputs.skip_deploy != 'true'
        uses: ./.github/actions/bootstrap-cdk

      - name: Deploy test stack
        if: steps.check-deployment.outputs.skip_deploy != 'true'
        env:
          STACK_NAME: ${{ steps.stack-name.outputs.stack_name }}
          APP_NAME: silvermoat-test
          STAGE_NAME: test
          UI_SEEDING_MODE: external
          CREATE_CLOUDFRONT: false
          DOMAIN_NAME: ""
        run: |
          echo "Deploying test stack: ${STACK_NAME}"
          chmod +x scripts/deploy-stack.sh
          ./scripts/deploy-stack.sh

  deploy-ui:
    name: Deploy UI
    needs: [deploy-stack]
    if: |
      always() &&
      (needs.deploy-stack.result == 'success' || needs.deploy-stack.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10

    outputs:
      stack_name: ${{ steps.stack-name.outputs.stack_name }}
      api_url: ${{ steps.stack-outputs.outputs.api_url }}
      web_url: ${{ steps.stack-outputs.outputs.web_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup environment
        uses: ./.github/actions/setup-env

      - name: Install dependencies
        uses: ./.github/actions/install-deps

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: us-east-1

      - name: Determine stack name
        id: stack-name
        run: |
          # Use output from deploy-stack if available, otherwise recalculate
          if [ "${{ needs.deploy-stack.result }}" = "success" ]; then
            STACK_NAME="${{ needs.deploy-stack.outputs.stack_name }}"
          else
            # Recalculate (same logic as deploy-stack)
            if [ -n "${{ github.event.pull_request.number }}" ]; then
              STACK_NAME="silvermoat-test-pr-${{ github.event.pull_request.number }}"
            elif [ -n "${{ inputs.pr_number }}" ]; then
              STACK_NAME="silvermoat-test-pr-${{ inputs.pr_number }}"
            else
              STACK_NAME="silvermoat-test-${{ github.run_id }}"
            fi
          fi
          echo "stack_name=${STACK_NAME}" >> $GITHUB_OUTPUT
          echo "Stack name: ${STACK_NAME}"

      - name: Check if UI needs deployment
        id: check-ui
        run: |
          # If stack was just deployed, always deploy UI
          if [ "${{ needs.deploy-stack.result }}" = "success" ]; then
            echo "Stack was just deployed, UI needs deployment"
            echo "skip_ui=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Stack deployment was skipped, check if UI changed
          STACK_NAME="${{ steps.stack-name.outputs.stack_name }}"

          # Get UI bucket from stack outputs
          UI_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query 'Stacks[0].Outputs[?OutputKey==`UiBucketName`].OutputValue' \
            --output text 2>/dev/null || echo "")

          if [ -z "$UI_BUCKET" ]; then
            echo "âš ï¸ Could not find UI bucket, will deploy UI"
            echo "skip_ui=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Check if bucket has index.html
          if aws s3 ls "s3://${UI_BUCKET}/index.html" >/dev/null 2>&1; then
            echo "âœ… UI already deployed in bucket ${UI_BUCKET}"

            # Calculate hash of UI source to detect changes
            UI_HASH=$(find ui/src ui/public ui/index.html -type f -exec md5sum {} \; 2>/dev/null | sort | md5sum | cut -d' ' -f1)

            # Try to get stored hash from S3
            STORED_HASH=$(aws s3 cp "s3://${UI_BUCKET}/.ui-hash" - 2>/dev/null || echo "")

            if [ "${UI_HASH}" = "${STORED_HASH}" ]; then
              echo "âœ… UI source unchanged (hash: ${UI_HASH}), skipping rebuild"
              echo "skip_ui=true" >> $GITHUB_OUTPUT
            else
              echo "UI source changed (${UI_HASH} vs ${STORED_HASH}), will deploy"
              echo "skip_ui=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "UI not found in bucket, will deploy"
            echo "skip_ui=false" >> $GITHUB_OUTPUT
          fi

      - name: Build and deploy React UI
        if: steps.check-ui.outputs.skip_ui != 'true'
        env:
          STACK_NAME: ${{ steps.stack-name.outputs.stack_name }}
        run: |
          echo "Building and deploying React UI..."
          chmod +x scripts/deploy-ui.sh
          ./scripts/deploy-ui.sh

      - name: Summary of operations
        if: always()
        run: |
          echo "=== Deployment Summary ==="
          echo "Stack: ${{ steps.stack-name.outputs.stack_name }}"
          echo "Stack deployment: ${{ needs.deploy-stack.result }}"
          echo "UI deployment skipped: ${{ steps.check-ui.outputs.skip_ui }}"
          echo ""
          if [ "${{ needs.deploy-stack.result }}" = "skipped" ]; then
            echo "â­ï¸ Infrastructure unchanged - skipped deployment"
          fi
          if [ "${{ steps.check-ui.outputs.skip_ui }}" = "true" ]; then
            echo "âš¡ UI unchanged - saved ~2-3 minutes!"
          fi

      - name: Get stack outputs
        id: stack-outputs
        run: |
          STACK_NAME="${{ steps.stack-name.outputs.stack_name }}"

          # Get all outputs as JSON
          OUTPUTS=$(aws cloudformation describe-stacks \
            --stack-name "${STACK_NAME}" \
            --query 'Stacks[0].Outputs' \
            --output json)

          # Extract specific outputs
          API_URL=$(echo "$OUTPUTS" | jq -r '.[] | select(.OutputKey=="ApiBaseUrl") | .OutputValue')

          # Try CloudFrontUrl first (production), fall back to WebUrl (test stacks)
          WEB_URL=$(echo "$OUTPUTS" | jq -r '.[] | select(.OutputKey=="CloudFrontUrl") | .OutputValue')
          if [ -z "$WEB_URL" ] || [ "$WEB_URL" == "null" ]; then
            WEB_URL=$(echo "$OUTPUTS" | jq -r '.[] | select(.OutputKey=="WebUrl") | .OutputValue')
          fi

          echo "api_url=${API_URL}" >> $GITHUB_OUTPUT
          echo "web_url=${WEB_URL}" >> $GITHUB_OUTPUT

          echo "API URL: ${API_URL}"
          echo "Web URL: ${WEB_URL}"

  tests:
    name: Run Tests
    needs: [deploy-stack, deploy-ui]
    if: always() && needs.deploy-ui.result == 'success'
    uses: ./.github/workflows/test-suite.yml
    with:
      stack_name: ${{ needs.deploy-ui.outputs.stack_name || needs.deploy-stack.outputs.stack_name }}
      api_url: ${{ needs.deploy-ui.outputs.api_url }}
      web_url: ${{ needs.deploy-ui.outputs.web_url }}
      environment: 'test'
    secrets:
      AWS_ROLE_ARN: ${{ secrets.AWS_ROLE_ARN }}

  clear-and-seed-data:
    name: Seed Demo Data
    needs: [deploy-stack, deploy-ui, tests]
    if: |
      always() &&
      (needs.deploy-stack.result == 'success' || needs.deploy-stack.result == 'skipped') &&
      needs.deploy-ui.result == 'success' &&
      needs.tests.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clear and seed demo data
        uses: ./.github/actions/clear-and-seed-data
        with:
          api-base-url: ${{ needs.deploy-ui.outputs.api_url }}

  pr-summary:
    name: Post PR Summary
    needs: [detect-changes, deploy-stack, deploy-ui, tests, clear-and-seed-data]
    if: always() && github.event.pull_request.number
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build PR summary comment
        id: summary
        run: |
          cat > /tmp/pr-comment.md <<'EOF'
          ## ðŸš€ Test Deployment Summary

          **PR**: #${{ github.event.pull_request.number }}
          **Workflow Run**: [View Details](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ---

          ### ðŸ“¦ Stack Deployment
          EOF

          # Stack deployment status
          STACK_RESULT="${{ needs.deploy-stack.result }}"
          if [ "$STACK_RESULT" = "success" ]; then
            echo "âœ… **Deployed** - Stack deployed successfully" >> /tmp/pr-comment.md
            echo "- Stack: \`${{ needs.deploy-stack.outputs.stack_name }}\`" >> /tmp/pr-comment.md
          elif [ "$STACK_RESULT" = "skipped" ]; then
            SKIP_REASON="${{ needs.deploy-stack.outputs.skip_reason }}"
            if [ -z "$SKIP_REASON" ]; then
              SKIP_REASON="No infrastructure changes detected"
            fi
            echo "â­ï¸ **Skipped** - ${SKIP_REASON}" >> /tmp/pr-comment.md
          elif [ "$STACK_RESULT" = "failure" ]; then
            echo "âŒ **Failed** - Stack deployment failed" >> /tmp/pr-comment.md
          else
            echo "âš ï¸ **${STACK_RESULT}** - Unexpected status" >> /tmp/pr-comment.md
          fi

          cat >> /tmp/pr-comment.md <<'EOF'

          ### ðŸŽ¨ UI Deployment
          EOF

          # UI deployment status
          UI_RESULT="${{ needs.deploy-ui.result }}"
          if [ "$UI_RESULT" = "success" ]; then
            echo "âœ… **Deployed** - UI built and deployed successfully" >> /tmp/pr-comment.md
            echo "- Web URL: ${{ needs.deploy-ui.outputs.web_url }}" >> /tmp/pr-comment.md
            echo "- API URL: ${{ needs.deploy-ui.outputs.api_url }}" >> /tmp/pr-comment.md
          elif [ "$UI_RESULT" = "skipped" ]; then
            echo "â­ï¸ **Skipped** - UI deployment was skipped" >> /tmp/pr-comment.md
          elif [ "$UI_RESULT" = "failure" ]; then
            echo "âŒ **Failed** - UI deployment failed" >> /tmp/pr-comment.md
          else
            echo "âš ï¸ **${UI_RESULT}** - Unexpected status" >> /tmp/pr-comment.md
          fi

          cat >> /tmp/pr-comment.md <<'EOF'

          ### ðŸ§ª Tests
          EOF

          # Test results
          TESTS_RESULT="${{ needs.tests.result }}"
          if [ "$TESTS_RESULT" = "success" ]; then
            echo "âœ… **Passed** - All tests passed" >> /tmp/pr-comment.md
          elif [ "$TESTS_RESULT" = "failure" ]; then
            echo "âŒ **Failed** - Some tests failed (see workflow details)" >> /tmp/pr-comment.md
          elif [ "$TESTS_RESULT" = "skipped" ]; then
            echo "â­ï¸ **Skipped** - Tests were skipped" >> /tmp/pr-comment.md
          else
            echo "âš ï¸ **${TESTS_RESULT}** - Unexpected status" >> /tmp/pr-comment.md
          fi

          cat >> /tmp/pr-comment.md <<'EOF'

          ### ðŸŒ± Demo Data Seeding
          EOF

          # Data seeding status
          SEED_RESULT="${{ needs.clear-and-seed-data.result }}"
          if [ "$SEED_RESULT" = "success" ]; then
            echo "âœ… **Completed** - Demo data seeded successfully" >> /tmp/pr-comment.md
          elif [ "$SEED_RESULT" = "skipped" ]; then
            echo "â­ï¸ **Skipped** - Data seeding was skipped" >> /tmp/pr-comment.md
          elif [ "$SEED_RESULT" = "failure" ]; then
            echo "âŒ **Failed** - Data seeding failed" >> /tmp/pr-comment.md
          else
            echo "âš ï¸ **${SEED_RESULT}** - Unexpected status" >> /tmp/pr-comment.md
          fi

          cat >> /tmp/pr-comment.md <<'EOF'

          ---

          ### â±ï¸ Job Timing
          EOF

          # Get job timing from GitHub API
          echo "Fetching job timings..." >> /tmp/pr-comment.md
          echo "" >> /tmp/pr-comment.md

          cat >> /tmp/pr-comment.md <<'EOF'

          ---

          <sub>ðŸ¤– Auto-generated summary from test deployment workflow</sub>
          EOF

          echo "Generated comment:"
          cat /tmp/pr-comment.md

      - name: Fetch job timing from GitHub API
        id: timing
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Fetch workflow run jobs
          gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" \
            > /tmp/jobs.json

          # Extract timing for key jobs
          echo "| Job | Duration | Status |" > /tmp/timing.md
          echo "|-----|----------|--------|" >> /tmp/timing.md

          # Parse job data (looking for specific job names)
          for job_name in "deploy-stack" "deploy-ui" "unit-tests" "api-tests" "e2e-tests" "clear-and-seed-data"; do
            # Get job info
            JOB_DATA=$(jq -r --arg name "$job_name" '.jobs[] | select(.name | contains($name)) | "\(.conclusion)|\(.started_at)|\(.completed_at)"' /tmp/jobs.json | head -1)

            if [ -n "$JOB_DATA" ]; then
              CONCLUSION=$(echo "$JOB_DATA" | cut -d'|' -f1)
              START=$(echo "$JOB_DATA" | cut -d'|' -f2)
              END=$(echo "$JOB_DATA" | cut -d'|' -f3)

              if [ "$END" != "null" ] && [ "$START" != "null" ]; then
                # Calculate duration in seconds
                START_SEC=$(date -u -d "$START" +%s 2>/dev/null || date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$START" +%s 2>/dev/null || echo "0")
                END_SEC=$(date -u -d "$END" +%s 2>/dev/null || date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$END" +%s 2>/dev/null || echo "0")
                DURATION=$((END_SEC - START_SEC))

                # Format duration
                if [ $DURATION -ge 60 ]; then
                  MIN=$((DURATION / 60))
                  SEC=$((DURATION % 60))
                  DURATION_STR="${MIN}m ${SEC}s"
                else
                  DURATION_STR="${DURATION}s"
                fi
              else
                DURATION_STR="in progress"
              fi

              # Status emoji
              case "$CONCLUSION" in
                success) STATUS="âœ…" ;;
                failure) STATUS="âŒ" ;;
                skipped) STATUS="â­ï¸" ;;
                cancelled) STATUS="ðŸš«" ;;
                *) STATUS="âš ï¸" ;;
              esac

              echo "| $job_name | $DURATION_STR | $STATUS |" >> /tmp/timing.md
            fi
          done

          echo "Timing table:"
          cat /tmp/timing.md

      - name: Insert timing into comment
        run: |
          # Replace placeholder with actual timing
          sed -i '/Fetching job timings.../r /tmp/timing.md' /tmp/pr-comment.md
          sed -i '/Fetching job timings.../d' /tmp/pr-comment.md

          echo "Final comment:"
          cat /tmp/pr-comment.md

      - name: Post comment to PR
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh pr comment ${{ github.event.pull_request.number }} --body-file /tmp/pr-comment.md
