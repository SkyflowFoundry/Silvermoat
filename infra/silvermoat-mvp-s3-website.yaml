AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Silvermoat Insurance - One-shot deployable MVP (CloudFormation only).
  S3 Website-hosted UI (NO CloudFront), API Gateway REST -> single Lambda (AWS_PROXY),
  DynamoDB tables, S3 docs, EventBridge, SNS, and a Custom Resource that seeds demo data + cleans up on delete.

Parameters:
  AppName:
    Type: String
    Default: silvermoat
    Description: "Short app name used in resource naming."

  StageName:
    Type: String
    Default: demo
    AllowedPattern: "^[a-zA-Z0-9_-]+$"
    Description: "API Gateway stage name."

  ApiDeploymentToken:
    Type: String
    Default: "v1"
    Description: >
      Change this value to force a new API Gateway deployment on updates
      (e.g., v2, v3...). Helps avoid 'API didn't update' confusion.

  UiSeedingMode:
    Type: String
    Default: "seeded"
    AllowedValues:
      - "seeded"
      - "external"
    Description: >
      "seeded" = Lambda uploads simple index.html (default for quick demo).
      "external" = UI is deployed separately (e.g., React SPA via deploy-ui.sh).
      When "external", skip index.html upload in seed mode.

Resources:

  # ----------------------------
  # S3 Buckets (UI Website + Docs)
  # ----------------------------
  UiBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Public website hosting requires public access.
      # Keep this ONLY for demo environments.
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      VersioningConfiguration:
        Status: Suspended

  UiBucketPolicy:
    Type: AWS::S3::BucketPolicy
    DependsOn: UiBucket
    Properties:
      Bucket: !Ref UiBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: PublicReadForWebsite
            Effect: Allow
            Principal: "*"
            Action: "s3:GetObject"
            Resource: !Sub "${UiBucket.Arn}/*"

  DocsBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Docs/media should remain private (Lambda only)
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Suspended

  # ----------------------------
  # DynamoDB Tables (PAY_PER_REQUEST)
  # ----------------------------
  QuotesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  PoliciesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  ClaimsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  PaymentsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  CasesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  # ----------------------------
  # SNS Topic (Demo notifications)
  # ----------------------------
  DemoNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub "${AppName}-${StageName}-demo-notifications"

  # ----------------------------
  # IAM Role for MVP Lambda
  # ----------------------------
  MvpLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub "${AppName}-${StageName}-mvp-policy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: Logs
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"

              - Sid: DynamoRW
                Effect: Allow
                Action:
                  - "dynamodb:GetItem"
                  - "dynamodb:PutItem"
                  - "dynamodb:UpdateItem"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:Scan"
                Resource:
                  - !GetAtt QuotesTable.Arn
                  - !GetAtt PoliciesTable.Arn
                  - !GetAtt ClaimsTable.Arn
                  - !GetAtt PaymentsTable.Arn
                  - !GetAtt CasesTable.Arn

              - Sid: S3DocsList
                Effect: Allow
                Action: "s3:ListBucket"
                Resource: !GetAtt DocsBucket.Arn

              - Sid: S3DocsObjRW
                Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:PutObject"
                  - "s3:DeleteObject"
                Resource: !Sub "${DocsBucket.Arn}/*"

              - Sid: PutEvents
                Effect: Allow
                Action: "events:PutEvents"
                Resource: "*"

              - Sid: PublishSNS
                Effect: Allow
                Action: "sns:Publish"
                Resource: !Ref DemoNotificationsTopic

              - Sid: BedrockInvoke
                Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-5-sonnet-20240620-v1:0"

  # ----------------------------
  # MVP Service Lambda (single function; routes by path)
  # ----------------------------
  MvpServiceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt MvpLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          QUOTES_TABLE: !Ref QuotesTable
          POLICIES_TABLE: !Ref PoliciesTable
          CLAIMS_TABLE: !Ref ClaimsTable
          PAYMENTS_TABLE: !Ref PaymentsTable
          CASES_TABLE: !Ref CasesTable
          DOCS_BUCKET: !Ref DocsBucket
          SNS_TOPIC_ARN: !Ref DemoNotificationsTopic
          BEDROCK_MODEL_ID: anthropic.claude-3-5-sonnet-20240620-v1:0
          BEDROCK_REGION: !Ref AWS::Region
      Code:
        ZipFile: |
          import os, json, uuid, time
          from decimal import Decimal
          import boto3

          ddb = boto3.resource("dynamodb")
          s3 = boto3.client("s3")
          eb = boto3.client("events")
          sns = boto3.client("sns")
          bedrock = boto3.client("bedrock-runtime", region_name=os.environ.get("BEDROCK_REGION", "us-east-1"))

          T = {
            "quote": ddb.Table(os.environ["QUOTES_TABLE"]),
            "policy": ddb.Table(os.environ["POLICIES_TABLE"]),
            "claim": ddb.Table(os.environ["CLAIMS_TABLE"]),
            "payment": ddb.Table(os.environ["PAYMENTS_TABLE"]),
            "case": ddb.Table(os.environ["CASES_TABLE"]),
          }
          DOCS_BUCKET = os.environ["DOCS_BUCKET"]
          TOPIC = os.environ["SNS_TOPIC_ARN"]
          BEDROCK_MODEL_ID = os.environ.get("BEDROCK_MODEL_ID", "anthropic.claude-3-5-sonnet-20240620-v1:0")

          TOOLS = [
            {
              "name": "search_quotes",
              "description": "Search insurance quotes by customer name or ZIP code",
              "input_schema": {
                "type": "object",
                "properties": {
                  "name": {"type": "string", "description": "Customer name to search for"},
                  "zip": {"type": "string", "description": "ZIP code to search for"}
                }
              }
            },
            {
              "name": "search_policies",
              "description": "Search insurance policies by policy number, holder name, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "policy_number": {"type": "string", "description": "Policy number"},
                  "holder_name": {"type": "string", "description": "Policy holder name"},
                  "status": {"type": "string", "enum": ["ACTIVE", "EXPIRED", "CANCELLED"]}
                }
              }
            },
            {
              "name": "search_claims",
              "description": "Search insurance claims by claim number, claimant name, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "claim_number": {"type": "string", "description": "Claim number"},
                  "claimant_name": {"type": "string", "description": "Claimant name"},
                  "status": {"type": "string", "enum": ["PENDING", "REVIEW", "APPROVED", "DENIED"]}
                }
              }
            },
            {
              "name": "search_payments",
              "description": "Search payments by policy ID or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "policy_id": {"type": "string", "description": "Related policy ID"},
                  "status": {"type": "string", "enum": ["PENDING", "COMPLETED", "FAILED"]}
                }
              }
            },
            {
              "name": "search_cases",
              "description": "Search cases by title, assignee, priority, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "title": {"type": "string", "description": "Case title keywords"},
                  "assignee": {"type": "string", "description": "Assigned employee name"},
                  "priority": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH"]},
                  "status": {"type": "string", "enum": ["OPEN", "IN_PROGRESS", "RESOLVED", "CLOSED"]}
                }
              }
            },
            {
              "name": "get_entity_details",
              "description": "Get full details of a specific quote, policy, claim, payment, or case by ID",
              "input_schema": {
                "type": "object",
                "properties": {
                  "entity_type": {"type": "string", "enum": ["quote", "policy", "claim", "payment", "case"]},
                  "entity_id": {"type": "string", "description": "The unique ID of the entity"}
                },
                "required": ["entity_type", "entity_id"]
              }
            }
          ]

          def decimal_default(obj):
            if isinstance(obj, Decimal):
              return int(obj) if obj % 1 == 0 else float(obj)
            raise TypeError

          def _resp(code, body):
            return {
              "statusCode": code,
              "headers": {
                "content-type": "application/json",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type"
              },
              "body": json.dumps(body, default=decimal_default),
            }

          def _emit(detail_type, detail):
            # Best-effort: events + demo notifications
            try:
              eb.put_events(Entries=[{
                "Source": "silvermoat.mvp",
                "DetailType": detail_type,
                "Detail": json.dumps(detail, default=decimal_default)
              }])
            except Exception:
              pass
            try:
              sns.publish(TopicArn=TOPIC, Subject=detail_type, Message=json.dumps(detail, default=decimal_default))
            except Exception:
              pass

          def execute_tool(tool_name, tool_input):
            """Execute a tool call and return results"""

            if tool_name == "search_quotes":
              table = T["quote"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by name or zip if provided
              if tool_input.get("name"):
                name_lower = tool_input["name"].lower()
                items = [i for i in items if name_lower in i.get("data", {}).get("name", "").lower()]
              if tool_input.get("zip"):
                items = [i for i in items if tool_input["zip"] == i.get("data", {}).get("zip")]

              return {"quotes": items[:10], "count": len(items)}

            elif tool_name == "search_policies":
              table = T["policy"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("policy_number"):
                pn = tool_input["policy_number"].lower()
                items = [i for i in items if pn in i.get("data", {}).get("policyNumber", "").lower()]
              if tool_input.get("holder_name"):
                hn = tool_input["holder_name"].lower()
                items = [i for i in items if hn in i.get("data", {}).get("holderName", "").lower()]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"policies": items[:10], "count": len(items)}

            elif tool_name == "search_claims":
              table = T["claim"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("claim_number"):
                cn = tool_input["claim_number"].lower()
                items = [i for i in items if cn in i.get("data", {}).get("claimNumber", "").lower()]
              if tool_input.get("claimant_name"):
                cn = tool_input["claimant_name"].lower()
                items = [i for i in items if cn in i.get("data", {}).get("claimantName", "").lower()]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("status")]

              return {"claims": items[:10], "count": len(items)}

            elif tool_name == "search_payments":
              table = T["payment"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("policy_id"):
                items = [i for i in items if tool_input["policy_id"] == i.get("data", {}).get("policyId")]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"payments": items[:10], "count": len(items)}

            elif tool_name == "search_cases":
              table = T["case"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("title"):
                title = tool_input["title"].lower()
                items = [i for i in items if title in i.get("data", {}).get("title", "").lower()]
              if tool_input.get("assignee"):
                assignee = tool_input["assignee"].lower()
                items = [i for i in items if assignee in i.get("data", {}).get("assignee", "").lower()]
              if tool_input.get("priority"):
                items = [i for i in items if tool_input["priority"] == i.get("data", {}).get("priority")]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"cases": items[:10], "count": len(items)}

            elif tool_name == "get_entity_details":
              entity_type = tool_input["entity_type"]
              entity_id = tool_input["entity_id"]

              if entity_type not in T:
                return {"error": f"Unknown entity type: {entity_type}"}

              table = T[entity_type]
              response = table.get_item(Key={"id": entity_id})

              if "Item" not in response:
                return {"error": f"{entity_type} not found"}

              return {entity_type: response["Item"]}

            return {"error": "Unknown tool"}

          def handler(event, context):
            path = (event.get("path") or "/").strip("/")
            method = (event.get("httpMethod") or "GET").upper()
            
            # Handle CORS preflight
            if method == "OPTIONS":
              return _resp(200, {"message": "CORS preflight"})

            # POST /chat -> chatbot endpoint (handle before domain check)
            if path == "chat" and method == "POST":
              try:
                body = json.loads(event.get("body", "{}"))
                user_message = body.get("message", "")
                conversation_history = body.get("history", [])

                if not user_message:
                  return _resp(400, {"error": "message_required", "message": "Message is required"})

                # Build messages for Claude
                messages = conversation_history + [{"role": "user", "content": user_message}]

                # System prompt for insurance assistant
                system_prompt = "You are a helpful AI assistant for Silvermoat Insurance employees. You help employees search customer data, fill forms, and generate reports. When users ask about customers, policies, or claims, use the available tools to search the database. Be professional, concise, and accurate. Format data clearly for insurance context. When helping with forms, provide structured data that can pre-fill form fields."

                # Invoke Bedrock with tool use
                response = bedrock.invoke_model(
                  modelId=BEDROCK_MODEL_ID,
                  body=json.dumps({
                    "anthropic_version": "bedrock-2023-05-31",
                    "max_tokens": 4096,
                    "system": system_prompt,
                    "messages": messages,
                    "tools": TOOLS,
                    "temperature": 0.7
                  })
                )

                response_body = json.loads(response["body"].read())

                # Handle tool use loop
                while response_body.get("stop_reason") == "tool_use":
                  # Extract tool calls
                  assistant_message = {
                    "role": "assistant",
                    "content": response_body["content"]
                  }
                  messages.append(assistant_message)

                  # Execute tools
                  tool_results = []
                  for content_block in response_body["content"]:
                    if content_block["type"] == "tool_use":
                      tool_name = content_block["name"]
                      tool_input = content_block["input"]
                      tool_use_id = content_block["id"]

                      # Execute the tool
                      result = execute_tool(tool_name, tool_input)

                      tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": tool_use_id,
                        "content": json.dumps(result, default=decimal_default)
                      })

                  # Send tool results back to Claude
                  messages.append({
                    "role": "user",
                    "content": tool_results
                  })

                  # Continue conversation
                  response = bedrock.invoke_model(
                    modelId=BEDROCK_MODEL_ID,
                    body=json.dumps({
                      "anthropic_version": "bedrock-2023-05-31",
                      "max_tokens": 4096,
                      "system": system_prompt,
                      "messages": messages,
                      "tools": TOOLS,
                      "temperature": 0.7
                    })
                  )

                  response_body = json.loads(response["body"].read())

                # Extract final response
                assistant_content = response_body["content"]
                text_content = next((block["text"] for block in assistant_content if block["type"] == "text"), "")

                return _resp(200, {
                  "response": text_content,
                  "usage": response_body.get("usage", {}),
                  "conversation": messages + [{"role": "assistant", "content": assistant_content}]
                })

              except Exception as e:
                print(f"Chat error: {str(e)}")
                return _resp(500, {"error": "chat_error", "message": str(e)})

            parts = [p for p in path.split("/") if p]

            if not parts:
              return _resp(200, {
                "name": "Silvermoat MVP",
                "endpoints": ["/quote", "/policy", "/claim", "/payment", "/case", "/chat"]
              })

            domain = parts[0]
            if domain not in T:
              return _resp(404, {"error": "unknown_domain", "domain": domain})

            table = T[domain]
            body = {}
            if event.get("body"):
              try:
                body = json.loads(event["body"])
              except Exception:
                body = {"raw": event["body"]}

            # GET /{domain} -> list all items
            if method == "GET" and len(parts) == 1:
              response = table.scan()
              items = response.get("Items", [])
              # Sort by createdAt descending (most recent first)
              items.sort(key=lambda x: x.get("createdAt", 0), reverse=True)
              return _resp(200, {"items": items, "count": len(items)})

            # POST /{domain} -> create
            if method == "POST" and len(parts) == 1:
              _id = str(uuid.uuid4())
              item = {"id": _id, "createdAt": int(time.time()), "data": body}
              table.put_item(Item=item)
              _emit(f"{domain}.created", {"id": _id, "data": body})
              return _resp(201, {"id": _id, "item": item})

            # GET /{domain}/{id} -> read
            if method == "GET" and len(parts) == 2:
              _id = parts[1]
              r = table.get_item(Key={"id": _id})
              if "Item" not in r:
                return _resp(404, {"error": "not_found", "id": _id})
              return _resp(200, r["Item"])

            # POST /claim/{id}/status -> simple state update demo
            if domain == "claim" and method == "POST" and len(parts) == 3 and parts[2] == "status":
              _id = parts[1]
              new_status = (body.get("status") or "REVIEW").upper()
              table.update_item(
                Key={"id": _id},
                UpdateExpression="SET #s = :s, updatedAt = :u",
                ExpressionAttributeNames={"#s": "status"},
                ExpressionAttributeValues={":s": new_status, ":u": int(time.time())},
              )
              _emit("claim.status_changed", {"id": _id, "status": new_status})
              return _resp(200, {"id": _id, "status": new_status})

            # POST /claim/{id}/doc -> attach a tiny doc to S3 (demo)
            if domain == "claim" and method == "POST" and len(parts) == 3 and parts[2] == "doc":
              _id = parts[1]
              key = f"claims/{_id}/note.txt"
              content = (body.get("text") or "Demo claim note").encode("utf-8")
              s3.put_object(
                Bucket=DOCS_BUCKET,
                Key=key,
                Body=content,
                ContentType="text/plain"
              )
              _emit("claim.document_added", {"id": _id, "s3Key": key})
              return _resp(200, {"id": _id, "s3Key": key})

            return _resp(400, {"error": "unsupported_operation", "path": event.get("path"), "method": method})

  # ----------------------------
  # API Gateway (REST proxy to Lambda)
  # ----------------------------
  Api:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AppName}-${StageName}-api"
      EndpointConfiguration:
        Types: [REGIONAL]

  ApiRootMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref Api
      ResourceId: !GetAtt Api.RootResourceId
      HttpMethod: ANY
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MvpServiceFunction.Arn}/invocations"

  ApiProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref Api
      ParentId: !GetAtt Api.RootResourceId
      PathPart: "{proxy+}"

  ApiProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref Api
      ResourceId: !Ref ApiProxyResource
      HttpMethod: ANY
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.proxy: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MvpServiceFunction.Arn}/invocations"

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiRootMethod
      - ApiProxyMethod
    Properties:
      RestApiId: !Ref Api
      Description: !Sub "Deployment token: ${ApiDeploymentToken}"

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref Api
      DeploymentId: !Ref ApiDeployment
      StageName: !Ref StageName

  ApiInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !Ref MvpServiceFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${Api}/*/*/*"

  # ----------------------------
  # Seeder Lambda (Custom Resource): seeds UI + demo data; cleans on delete
  # ----------------------------
  SeederLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub "${AppName}-${StageName}-seeder-policy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: Logs
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"

              - Sid: S3ListBuckets
                Effect: Allow
                Action:
                  - "s3:ListBucket"
                  - "s3:ListBucketVersions"
                Resource:
                  - !GetAtt UiBucket.Arn
                  - !GetAtt DocsBucket.Arn

              - Sid: S3Objects
                Effect: Allow
                Action:
                  - "s3:PutObject"
                  - "s3:GetObject"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                Resource:
                  - !Sub "${UiBucket.Arn}/*"
                  - !Sub "${DocsBucket.Arn}/*"

              - Sid: DynamoSeedAndCleanup
                Effect: Allow
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:Scan"
                  - "dynamodb:DeleteItem"
                Resource:
                  - !GetAtt QuotesTable.Arn
                  - !GetAtt PoliciesTable.Arn
                  - !GetAtt ClaimsTable.Arn
                  - !GetAtt PaymentsTable.Arn
                  - !GetAtt CasesTable.Arn

  SeederFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt SeederLambdaRole.Arn
      Timeout: 120
      MemorySize: 256
      Environment:
        Variables:
          UI_BUCKET: !Ref UiBucket
          DOCS_BUCKET: !Ref DocsBucket
          QUOTES_TABLE: !Ref QuotesTable
          POLICIES_TABLE: !Ref PoliciesTable
          CLAIMS_TABLE: !Ref ClaimsTable
          PAYMENTS_TABLE: !Ref PaymentsTable
          CASES_TABLE: !Ref CasesTable
          API_BASE: !Sub "https://${Api}.execute-api.${AWS::Region}.amazonaws.com/${StageName}"
          WEB_BASE: !GetAtt UiBucket.WebsiteURL
      Code:
        ZipFile: |
          import os, json, boto3, urllib.request, urllib.error

          s3 = boto3.client("s3")
          ddb = boto3.resource("dynamodb")

          def send(event, status, data, phys_id, reason=None):
            if reason is None:
              reason = "See CloudWatch logs for details"

            response_body = {
              "Status": status,
              "Reason": reason,
              "PhysicalResourceId": phys_id,
              "StackId": event["StackId"],
              "RequestId": event["RequestId"],
              "LogicalResourceId": event["LogicalResourceId"],
              "Data": data,
            }

            body = json.dumps(response_body).encode("utf-8")
            response_url = event.get("ResponseURL")

            if not response_url:
              raise ValueError("ResponseURL is missing from event")

            print(f"Sending {status} response to CloudFormation")
            print(f"ResponseURL: {response_url[:100]}...")  # Log partial URL for security

            req = urllib.request.Request(
              response_url,
              data=body,
              method="PUT",
              headers={
                "content-type": "",
                "content-length": str(len(body)),
              },
            )

            try:
              with urllib.request.urlopen(req, timeout=30) as response:
                response_code = response.getcode()
                print(f"Response sent successfully. HTTP {response_code}")
                if response_code != 200:
                  print(f"Warning: Expected 200, got {response_code}")
            except urllib.error.HTTPError as e:
              error_msg = f"HTTP error sending response: {e.code} {e.reason}"
              print(error_msg)
              try:
                error_body = e.read().decode("utf-8")
                print(f"Error response body: {error_body}")
              except Exception:
                pass
              raise Exception(f"Could not send response to CloudFormation: {error_msg}")
            except Exception as e:
              error_msg = f"Failed to send response: {type(e).__name__}: {str(e)}"
              print(error_msg)
              print(f"Body length: {len(body)}")
              print(f"Response body preview: {body[:200]}")
              raise Exception(f"Could not send response to CloudFormation: {error_msg}")

          def empty_bucket(bucket):
            print(f"Emptying bucket: {bucket}")
            deleted_count = 0
            
            # Delete all object versions + delete markers (works for versioned and non-versioned buckets)
            try:
              paginator = s3.get_paginator("list_object_versions")
              for page in paginator.paginate(Bucket=bucket):
                to_delete = []

                for v in page.get("Versions", []):
                  to_delete.append({"Key": v["Key"], "VersionId": v["VersionId"]})

                for m in page.get("DeleteMarkers", []):
                  to_delete.append({"Key": m["Key"], "VersionId": m["VersionId"]})

                if to_delete:
                  for i in range(0, len(to_delete), 1000):
                    batch = to_delete[i : i + 1000]
                    s3.delete_objects(Bucket=bucket, Delete={"Objects": batch})
                    deleted_count += len(batch)
                    print(f"Deleted {len(batch)} object versions/markers from {bucket}")
            except s3.exceptions.NoSuchBucket:
              print(f"Bucket {bucket} does not exist, skipping")
              return
            except Exception as e:
              # If bucket is not versioned or API is restricted, fall back to non-versioned deletion
              error_name = type(e).__name__
              if "NoSuchBucket" in error_name or "404" in str(e):
                print(f"Bucket {bucket} does not exist, skipping")
                return
              print(f"list_object_versions failed or not applicable for {bucket}: {error_name}: {e}")

            # Delete current objects (covers non-versioned and any remaining current keys)
            token = None
            while True:
              kwargs = {"Bucket": bucket}
              if token:
                kwargs["ContinuationToken"] = token
              try:
                r = s3.list_objects_v2(**kwargs)
                objs = [{"Key": o["Key"]} for o in r.get("Contents", [])]
                if objs:
                  for i in range(0, len(objs), 1000):
                    batch = objs[i : i + 1000]
                    s3.delete_objects(Bucket=bucket, Delete={"Objects": batch})
                    deleted_count += len(batch)
                    print(f"Deleted {len(batch)} objects from {bucket}")
                if r.get("IsTruncated"):
                  token = r.get("NextContinuationToken")
                else:
                  break
              except s3.exceptions.NoSuchBucket:
                print(f"Bucket {bucket} does not exist, skipping")
                return
              except Exception as e:
                error_name = type(e).__name__
                if "NoSuchBucket" in error_name or "404" in str(e):
                  print(f"Bucket {bucket} does not exist, skipping")
                  return
                raise
            
            if deleted_count == 0:
              print(f"Bucket {bucket} was already empty")
            else:
              print(f"Bucket {bucket} emptied successfully ({deleted_count} items deleted)")

          def wipe_table(name):
            t = ddb.Table(name)
            start_key = None
            while True:
              kwargs = {"ProjectionExpression": "id"}
              if start_key:
                kwargs["ExclusiveStartKey"] = start_key
              r = t.scan(**kwargs)
              for it in r.get("Items", []):
                t.delete_item(Key={"id": it["id"]})
              start_key = r.get("LastEvaluatedKey")
              if not start_key:
                break

          def handler(event, context):
            print(f"Custom Resource Handler invoked. RequestType: {event.get('RequestType')}")
            print(f"Event keys: {list(event.keys())}")

            props = event.get("ResourceProperties", {})
            mode = props.get("Mode", "seed")
            request_type = event.get("RequestType", "Create")

            print(f"Mode: {mode}")
            print(f"Processing RequestType: {request_type}, Mode: {mode}")

            phys_id = f"silvermoat-{mode}-{event.get('StackId','').split('/')[-1]}"

            try:
              ui_bucket = os.environ["UI_BUCKET"]
              docs_bucket = os.environ["DOCS_BUCKET"]
              tables = [
                os.environ["QUOTES_TABLE"],
                os.environ["POLICIES_TABLE"],
                os.environ["CLAIMS_TABLE"],
                os.environ["PAYMENTS_TABLE"],
                os.environ["CASES_TABLE"],
              ]
              api = os.environ.get("API_BASE", "")
              web = os.environ.get("WEB_BASE", "")

              print(f"UI_BUCKET: {ui_bucket}")
              print(f"DOCS_BUCKET: {docs_bucket}")
              print(f"API_BASE: {api}")
              print(f"WEB_BASE: {web}")

              # -------------------------
              # Cleanup mode
              # -------------------------
              if mode == "cleanup":
                if request_type == "Delete":
                  print("Starting cleanup...")
                  for tn in tables:
                    print(f"Wiping table: {tn}")
                    wipe_table(tn)

                  print(f"Emptying bucket: {ui_bucket}")
                  empty_bucket(ui_bucket)

                  print(f"Emptying bucket: {docs_bucket}")
                  empty_bucket(docs_bucket)

                  send(event, "SUCCESS", {"message": "cleaned"}, phys_id, "Cleanup completed successfully")
                else:
                  # Create/Update: no-op
                  print("Cleanup mode: Create/Update - no action needed")
                  send(event, "SUCCESS", {"message": "cleanup resource ready"}, phys_id, "Cleanup resource initialized")
                return

              # -------------------------
              # Seed mode
              # -------------------------
              if mode == "seed":
                if request_type == "Delete":
                  # Delete: no-op (cleanup is handled by CleanupCustomResource)
                  print("Seed mode: Delete - no action needed")
                  send(event, "SUCCESS", {"message": "seed resource deleted"}, phys_id, "Seed resource deleted")
                  return

                if request_type in ["Create", "Update"]:
                  print("Starting seeding process...")

                  # Seed UI (only if UiSeedingMode is "seeded")
                  ui_seeding_mode = props.get("UiSeedingMode", "seeded")
                  print(f"UiSeedingMode: {ui_seeding_mode}")
                  
                  if ui_seeding_mode == "seeded":
                    print(f"Uploading index.html to {ui_bucket}")
                    html = f"""<!doctype html>
                <html><head><meta charset=\"utf-8\"><title>Silvermoat Insurance Demo</title></head>
                <body style=\"font-family:Arial;padding:24px\">
                  <h1>Silvermoat Insurance</h1>
                  <p>One-shot CloudFormation MVP (S3 Website Hosting)</p>
                  <ul>
                    <li>API Base: <code>{api}</code></li>
                    <li>Web Base: <code>{web}</code></li>
                  </ul>
                  <button id=\"btn\">Create Quote</button>
                  <pre id=\"out\" style=\"margin-top:16px;background:#f7f7f7;padding:12px;border-radius:8px;\"></pre>
                  <script>
                    const out = document.getElementById(\"out\");
                    document.getElementById(\"btn\").onclick = async () => {{
                      const r = await fetch(\"{api}/quote\", {{
                        method:\"POST\",
                        headers:{{\"content-type\":\"application/json\"}},
                        body: JSON.stringify({{\"name\":\"Jane Doe\",\"zip\":\"33431\"}})
                      }});
                      out.textContent = await r.text();
                    }};
                  </script>
                </body></html>"""

                    s3.put_object(
                      Bucket=ui_bucket,
                      Key="index.html",
                      Body=html.encode("utf-8"),
                      ContentType="text/html",
                    )
                    print("index.html uploaded successfully")
                  else:
                    print(f"UiSeedingMode is '{ui_seeding_mode}' - skipping index.html upload (UI should be deployed externally)")

                  # Seed DynamoDB
                  print("Seeding DynamoDB tables...")

                  def put(table, item):
                    ddb.Table(table).put_item(Item=item)

                  put(tables[0], {"id": "q-001", "createdAt": 1, "data": {"name": "Jane Doe", "premium_cents": 12550}})
                  print(f"Seeded {tables[0]}")
                  put(tables[1], {"id": "p-001", "createdAt": 1, "data": {"quoteId": "q-001", "status": "BOUND"}})
                  print(f"Seeded {tables[1]}")
                  put(tables[2], {"id": "c-001", "createdAt": 1, "status": "INTAKE", "data": {"policyId": "p-001", "loss": "Windshield"}})
                  print(f"Seeded {tables[2]}")
                  put(tables[3], {"id": "pay-001", "createdAt": 1, "data": {"policyId": "p-001", "amount_cents": 12550}})
                  print(f"Seeded {tables[3]}")
                  put(tables[4], {"id": "case-001", "createdAt": 1, "data": {"topic": "Address change", "status": "OPEN"}})
                  print(f"Seeded {tables[4]}")

                  # Seed one doc
                  print(f"Uploading sample doc to {docs_bucket}")
                  s3.put_object(
                    Bucket=docs_bucket,
                    Key="docs/sample.txt",
                    Body=b"Silvermoat demo document",
                    ContentType="text/plain",
                  )
                  print("Sample doc uploaded successfully")

                  print("Seeding completed successfully")
                  send(event, "SUCCESS", {"web": web, "api": api}, phys_id, "Seeding completed successfully")
                  return

                raise ValueError(f"Unknown RequestType in seed mode: {request_type}")

              raise ValueError(f"Unknown Mode: {mode}")

            except Exception as e:
              error_msg = f"Error in Custom Resource handler: {str(e)}"
              print(error_msg)
              import traceback
              print(traceback.format_exc())
              try:
                send(event, "FAILED", {"error": str(e)}, phys_id, error_msg)
              except Exception as send_error:
                print(f"CRITICAL: Failed to send FAILED response: {send_error}")
                raise

  SeedCustomResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - ApiStage
      - UiBucket
      - DocsBucket
      - UiBucketPolicy
    Properties:
      ServiceToken: !GetAtt SeederFunction.Arn
      Mode: seed
      UiSeedingMode: !Ref UiSeedingMode

  CleanupCustomResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - UiBucket
      - DocsBucket
      - SeederFunction
    Properties:
      ServiceToken: !GetAtt SeederFunction.Arn
      Mode: cleanup

Outputs:
  WebUrl:
    Description: "S3 Website URL for the demo UI (HTTP)"
    Value: !GetAtt UiBucket.WebsiteURL

  ApiBaseUrl:
    Description: "API base URL (HTTPS)"
    Value: !Sub "https://${Api}.execute-api.${AWS::Region}.amazonaws.com/${StageName}"

  UiBucketName:
    Value: !Ref UiBucket

  DocsBucketName:
    Value: !Ref DocsBucket

  QuotesTableName:
    Value: !Ref QuotesTable
  PoliciesTableName:
    Value: !Ref PoliciesTable
  ClaimsTableName:
    Value: !Ref ClaimsTable
  PaymentsTableName:
    Value: !Ref PaymentsTable
  CasesTableName:
    Value: !Ref CasesTable

  DemoNotificationsTopicArn:
    Value: !Ref DemoNotificationsTopic