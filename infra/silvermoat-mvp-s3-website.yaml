AWSTemplateFormatVersion: "2010-09-09"
Description: >
  Silvermoat Insurance - One-shot deployable MVP (CloudFormation only).
  S3 Website-hosted UI with CloudFront CDN (HTTPS), API Gateway REST -> single Lambda (AWS_PROXY),
  DynamoDB tables, S3 docs, optional custom domain via ACM, and Custom Resources for seeding/cleanup.

Parameters:
  AppName:
    Type: String
    Default: silvermoat
    Description: "Short app name used in resource naming."

  StageName:
    Type: String
    Default: demo
    AllowedPattern: "^[a-zA-Z0-9_-]+$"
    Description: "API Gateway stage name."

  ApiDeploymentToken:
    Type: String
    Default: "v1"
    Description: >
      Change this value to force a new API Gateway deployment on updates
      (e.g., v2, v3...). Helps avoid 'API didn't update' confusion.

  UiSeedingMode:
    Type: String
    Default: "seeded"
    AllowedValues:
      - "seeded"
      - "external"
    Description: >
      "seeded" = Lambda uploads simple index.html (default for quick demo).
      "external" = UI is deployed separately (e.g., React SPA via deploy-ui.sh).
      When "external", skip index.html upload in seed mode.

  DomainName:
    Type: String
    Default: "silvermoat.net"
    Description: >
      Custom domain for CloudFront (default: silvermoat.net).
      Set to empty string ("") to disable custom domain and use only CloudFront default domain.
      To use custom domain: deploy stack, add DNS validation CNAME to Cloudflare,
      wait for cert validation, then add CloudFront alias CNAME to Cloudflare.

  CreateCloudFront:
    Type: String
    Default: "true"
    AllowedValues:
      - "true"
      - "false"
    Description: >
      Create CloudFront distribution (default: true).
      Set to "false" for ephemeral test stacks to use S3 website URL directly (HTTP).
      Production stacks should use "true" for HTTPS via CloudFront.

Conditions:
  HasDomainName: !Not [!Equals [!Ref DomainName, ""]]
  ShouldCreateCloudFront: !Equals [!Ref CreateCloudFront, "true"]
  ShouldCreateCertificate: !And
    - !Condition ShouldCreateCloudFront
    - !Condition HasDomainName

Resources:

  # ----------------------------
  # S3 Buckets (UI Website + Docs)
  # ----------------------------
  UiBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Public website hosting requires public access.
      # Keep this ONLY for demo environments.
      PublicAccessBlockConfiguration:
        BlockPublicAcls: false
        BlockPublicPolicy: false
        IgnorePublicAcls: false
        RestrictPublicBuckets: false
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: index.html
      VersioningConfiguration:
        Status: Suspended

  UiBucketPolicy:
    Type: AWS::S3::BucketPolicy
    DependsOn: UiBucket
    Properties:
      Bucket: !Ref UiBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: PublicReadForWebsite
            Effect: Allow
            Principal: "*"
            Action: "s3:GetObject"
            Resource: !Sub "${UiBucket.Arn}/*"

  # ----------------------------
  # SSL Certificate for CloudFront (only if DomainName provided)
  # ----------------------------

  UiCertificate:
    Type: AWS::CertificateManager::Certificate
    Condition: ShouldCreateCertificate
    Properties:
      DomainName: !Ref DomainName
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Ref DomainName
          ValidationDomain: !Ref DomainName

  # ----------------------------
  # CloudFront Distribution
  # ----------------------------

  UiDistribution:
    Type: AWS::CloudFront::Distribution
    Condition: ShouldCreateCloudFront
    Properties:
      DistributionConfig:
        # Custom domain aliases (only if DomainName provided)
        Aliases: !If
          - HasDomainName
          - - !Ref DomainName
          - !Ref "AWS::NoValue"

        # HTTPS certificate
        ViewerCertificate: !If
          - HasDomainName
          - AcmCertificateArn: !Ref UiCertificate
            SslSupportMethod: sni-only
            MinimumProtocolVersion: TLSv1.2_2021
          - CloudFrontDefaultCertificate: true

        # Origin: S3 website endpoint (not REST API endpoint)
        Origins:
          - Id: S3Origin
            DomainName: !Select [2, !Split ["/", !GetAtt UiBucket.WebsiteURL]]
            CustomOriginConfig:
              HTTPPort: 80
              OriginProtocolPolicy: http-only

        # Default cache behavior
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD, OPTIONS]
          Compress: true
          # Use managed caching policy optimized for SPAs
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6
          # Use managed origin request policy for CORS
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf

        # SPA routing: serve index.html for 404/403 errors
        CustomErrorResponses:
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
            ErrorCachingMinTTL: 300

        # Distribution settings
        Enabled: true
        DefaultRootObject: index.html
        HttpVersion: http2and3
        IPV6Enabled: true
        PriceClass: PriceClass_100
        Comment: !Sub "${AWS::StackName} UI Distribution"

  # ----------------------------
  # S3 Buckets (Docs)
  # ----------------------------

  DocsBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Docs/media should remain private (Lambda only)
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      VersioningConfiguration:
        Status: Suspended

  # ----------------------------
  # DynamoDB Tables (PAY_PER_REQUEST)
  # ----------------------------
  QuotesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  PoliciesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  ClaimsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  PaymentsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  CasesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH

  # ----------------------------
  # SNS Topic (Demo notifications)
  # ----------------------------
  DemoNotificationsTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub "${AppName}-${StageName}-demo-notifications"

  # ----------------------------
  # IAM Role for MVP Lambda
  # ----------------------------
  MvpLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub "${AppName}-${StageName}-mvp-policy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: Logs
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"

              - Sid: DynamoRW
                Effect: Allow
                Action:
                  - "dynamodb:GetItem"
                  - "dynamodb:PutItem"
                  - "dynamodb:UpdateItem"
                  - "dynamodb:DeleteItem"
                  - "dynamodb:Scan"
                Resource:
                  - !GetAtt QuotesTable.Arn
                  - !GetAtt PoliciesTable.Arn
                  - !GetAtt ClaimsTable.Arn
                  - !GetAtt PaymentsTable.Arn
                  - !GetAtt CasesTable.Arn

              - Sid: S3DocsList
                Effect: Allow
                Action: "s3:ListBucket"
                Resource: !GetAtt DocsBucket.Arn

              - Sid: S3DocsObjRW
                Effect: Allow
                Action:
                  - "s3:GetObject"
                  - "s3:PutObject"
                  - "s3:DeleteObject"
                Resource: !Sub "${DocsBucket.Arn}/*"

              - Sid: PutEvents
                Effect: Allow
                Action: "events:PutEvents"
                Resource: "*"

              - Sid: PublishSNS
                Effect: Allow
                Action: "sns:Publish"
                Resource: !Ref DemoNotificationsTopic

              - Sid: BedrockInvoke
                Effect: Allow
                Action:
                  - "bedrock:InvokeModel"
                Resource:
                  - !Sub "arn:aws:bedrock:${AWS::Region}::foundation-model/anthropic.claude-3-5-sonnet-20240620-v1:0"

  # ----------------------------
  # MVP Service Lambda (single function; routes by path)
  # ----------------------------
  MvpServiceFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt MvpLambdaRole.Arn
      Timeout: 30
      MemorySize: 256
      Environment:
        Variables:
          QUOTES_TABLE: !Ref QuotesTable
          POLICIES_TABLE: !Ref PoliciesTable
          CLAIMS_TABLE: !Ref ClaimsTable
          PAYMENTS_TABLE: !Ref PaymentsTable
          CASES_TABLE: !Ref CasesTable
          DOCS_BUCKET: !Ref DocsBucket
          SNS_TOPIC_ARN: !Ref DemoNotificationsTopic
          BEDROCK_MODEL_ID: anthropic.claude-3-5-sonnet-20240620-v1:0
          BEDROCK_REGION: !Ref AWS::Region
      Code:
        ZipFile: |
          import os, json, uuid, time
          from decimal import Decimal
          import boto3

          ddb = boto3.resource("dynamodb")
          s3 = boto3.client("s3")
          eb = boto3.client("events")
          sns = boto3.client("sns")
          bedrock = boto3.client("bedrock-runtime", region_name=os.environ.get("BEDROCK_REGION", "us-east-1"))

          T = {
            "quote": ddb.Table(os.environ["QUOTES_TABLE"]),
            "policy": ddb.Table(os.environ["POLICIES_TABLE"]),
            "claim": ddb.Table(os.environ["CLAIMS_TABLE"]),
            "payment": ddb.Table(os.environ["PAYMENTS_TABLE"]),
            "case": ddb.Table(os.environ["CASES_TABLE"]),
          }
          DOCS_BUCKET = os.environ["DOCS_BUCKET"]
          TOPIC = os.environ["SNS_TOPIC_ARN"]
          BEDROCK_MODEL_ID = os.environ.get("BEDROCK_MODEL_ID", "anthropic.claude-3-5-sonnet-20240620-v1:0")

          TOOLS = [
            {
              "name": "search_quotes",
              "description": "Search insurance quotes by customer name or ZIP code",
              "input_schema": {
                "type": "object",
                "properties": {
                  "name": {"type": "string", "description": "Customer name to search for"},
                  "zip": {"type": "string", "description": "ZIP code to search for"}
                }
              }
            },
            {
              "name": "search_policies",
              "description": "Search insurance policies by policy number, holder name, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "policy_number": {"type": "string", "description": "Policy number"},
                  "holder_name": {"type": "string", "description": "Policy holder name"},
                  "status": {"type": "string", "enum": ["ACTIVE", "EXPIRED", "CANCELLED"]}
                }
              }
            },
            {
              "name": "search_claims",
              "description": "Search insurance claims by claim number, claimant name, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "claim_number": {"type": "string", "description": "Claim number"},
                  "claimant_name": {"type": "string", "description": "Claimant name"},
                  "status": {"type": "string", "enum": ["PENDING", "REVIEW", "APPROVED", "DENIED"]}
                }
              }
            },
            {
              "name": "search_payments",
              "description": "Search payments by policy ID or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "policy_id": {"type": "string", "description": "Related policy ID"},
                  "status": {"type": "string", "enum": ["PENDING", "COMPLETED", "FAILED"]}
                }
              }
            },
            {
              "name": "search_cases",
              "description": "Search cases by title, assignee, priority, or status",
              "input_schema": {
                "type": "object",
                "properties": {
                  "title": {"type": "string", "description": "Case title keywords"},
                  "assignee": {"type": "string", "description": "Assigned employee name"},
                  "priority": {"type": "string", "enum": ["LOW", "MEDIUM", "HIGH"]},
                  "status": {"type": "string", "enum": ["OPEN", "IN_PROGRESS", "RESOLVED", "CLOSED"]}
                }
              }
            },
            {
              "name": "get_entity_details",
              "description": "Get full details of a specific quote, policy, claim, payment, or case by ID",
              "input_schema": {
                "type": "object",
                "properties": {
                  "entity_type": {"type": "string", "enum": ["quote", "policy", "claim", "payment", "case"]},
                  "entity_id": {"type": "string", "description": "The unique ID of the entity"}
                },
                "required": ["entity_type", "entity_id"]
              }
            }
          ]

          def decimal_default(obj):
            if isinstance(obj, Decimal):
              return int(obj) if obj % 1 == 0 else float(obj)
            raise TypeError

          def convert_floats_to_decimal(obj):
            """Recursively convert floats to Decimal for DynamoDB compatibility"""
            if isinstance(obj, list):
              return [convert_floats_to_decimal(item) for item in obj]
            elif isinstance(obj, dict):
              return {key: convert_floats_to_decimal(value) for key, value in obj.items()}
            elif isinstance(obj, float):
              return Decimal(str(obj))
            return obj

          def _resp(code, body):
            return {
              "statusCode": code,
              "headers": {
                "content-type": "application/json",
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "GET,POST,DELETE,OPTIONS",
                "Access-Control-Allow-Headers": "Content-Type"
              },
              "body": json.dumps(body, default=decimal_default),
            }

          def _emit(detail_type, detail):
            # Best-effort: events + demo notifications
            try:
              eb.put_events(Entries=[{
                "Source": "silvermoat.mvp",
                "DetailType": detail_type,
                "Detail": json.dumps(detail, default=decimal_default)
              }])
            except Exception:
              pass
            try:
              sns.publish(TopicArn=TOPIC, Subject=detail_type, Message=json.dumps(detail, default=decimal_default))
            except Exception:
              pass

          def execute_tool(tool_name, tool_input):
            """Execute a tool call and return results"""

            if tool_name == "search_quotes":
              table = T["quote"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by name or zip if provided
              if tool_input.get("name"):
                name_lower = tool_input["name"].lower()
                items = [i for i in items if name_lower in i.get("data", {}).get("name", "").lower()]
              if tool_input.get("zip"):
                items = [i for i in items if tool_input["zip"] == i.get("data", {}).get("zip")]

              return {"quotes": items[:10], "count": len(items)}

            elif tool_name == "search_policies":
              table = T["policy"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("policy_number"):
                pn = tool_input["policy_number"].lower()
                items = [i for i in items if pn in i.get("data", {}).get("policyNumber", "").lower()]
              if tool_input.get("holder_name"):
                hn = tool_input["holder_name"].lower()
                items = [i for i in items if hn in i.get("data", {}).get("holderName", "").lower()]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"policies": items[:10], "count": len(items)}

            elif tool_name == "search_claims":
              table = T["claim"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("claim_number"):
                cn = tool_input["claim_number"].lower()
                items = [i for i in items if cn in i.get("data", {}).get("claimNumber", "").lower()]
              if tool_input.get("claimant_name"):
                cn = tool_input["claimant_name"].lower()
                items = [i for i in items if cn in i.get("data", {}).get("claimantName", "").lower()]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("status")]

              return {"claims": items[:10], "count": len(items)}

            elif tool_name == "search_payments":
              table = T["payment"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("policy_id"):
                items = [i for i in items if tool_input["policy_id"] == i.get("data", {}).get("policyId")]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"payments": items[:10], "count": len(items)}

            elif tool_name == "search_cases":
              table = T["case"]
              response = table.scan()
              items = response.get("Items", [])

              # Filter by criteria
              if tool_input.get("title"):
                title = tool_input["title"].lower()
                items = [i for i in items if title in i.get("data", {}).get("title", "").lower()]
              if tool_input.get("assignee"):
                assignee = tool_input["assignee"].lower()
                items = [i for i in items if assignee in i.get("data", {}).get("assignee", "").lower()]
              if tool_input.get("priority"):
                items = [i for i in items if tool_input["priority"] == i.get("data", {}).get("priority")]
              if tool_input.get("status"):
                items = [i for i in items if tool_input["status"] == i.get("data", {}).get("status")]

              return {"cases": items[:10], "count": len(items)}

            elif tool_name == "get_entity_details":
              entity_type = tool_input["entity_type"]
              entity_id = tool_input["entity_id"]

              if entity_type not in T:
                return {"error": f"Unknown entity type: {entity_type}"}

              table = T[entity_type]
              response = table.get_item(Key={"id": entity_id})

              if "Item" not in response:
                return {"error": f"{entity_type} not found"}

              return {entity_type: response["Item"]}

            return {"error": "Unknown tool"}

          def handler(event, context):
            path = (event.get("path") or "/").strip("/")
            method = (event.get("httpMethod") or "GET").upper()
            
            # Handle CORS preflight
            if method == "OPTIONS":
              return _resp(200, {"message": "CORS preflight"})

            # POST /chat -> chatbot endpoint (handle before domain check)
            if path == "chat" and method == "POST":
              try:
                body = json.loads(event.get("body", "{}"))
                user_message = body.get("message", "")
                conversation_history = body.get("history", [])

                if not user_message:
                  return _resp(400, {"error": "message_required", "message": "Message is required"})

                # Build messages for Claude
                messages = conversation_history + [{"role": "user", "content": user_message}]

                # System prompt for insurance assistant
                system_prompt = "You are a helpful AI assistant for Silvermoat Insurance employees. You help employees search customer data, fill forms, and generate reports. When users ask about customers, policies, or claims, use the available tools to search the database. Be professional, concise, and accurate. Format data clearly for insurance context. When helping with forms, provide structured data that can pre-fill form fields."

                # Invoke Bedrock with tool use
                response = bedrock.invoke_model(
                  modelId=BEDROCK_MODEL_ID,
                  body=json.dumps({
                    "anthropic_version": "bedrock-2023-05-31",
                    "max_tokens": 4096,
                    "system": system_prompt,
                    "messages": messages,
                    "tools": TOOLS,
                    "temperature": 0.7
                  })
                )

                response_body = json.loads(response["body"].read())

                # Handle tool use loop
                while response_body.get("stop_reason") == "tool_use":
                  # Extract tool calls
                  assistant_message = {
                    "role": "assistant",
                    "content": response_body["content"]
                  }
                  messages.append(assistant_message)

                  # Execute tools
                  tool_results = []
                  for content_block in response_body["content"]:
                    if content_block["type"] == "tool_use":
                      tool_name = content_block["name"]
                      tool_input = content_block["input"]
                      tool_use_id = content_block["id"]

                      # Execute the tool
                      result = execute_tool(tool_name, tool_input)

                      tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": tool_use_id,
                        "content": json.dumps(result, default=decimal_default)
                      })

                  # Send tool results back to Claude
                  messages.append({
                    "role": "user",
                    "content": tool_results
                  })

                  # Continue conversation
                  response = bedrock.invoke_model(
                    modelId=BEDROCK_MODEL_ID,
                    body=json.dumps({
                      "anthropic_version": "bedrock-2023-05-31",
                      "max_tokens": 4096,
                      "system": system_prompt,
                      "messages": messages,
                      "tools": TOOLS,
                      "temperature": 0.7
                    })
                  )

                  response_body = json.loads(response["body"].read())

                # Extract final response
                assistant_content = response_body["content"]
                text_content = next((block["text"] for block in assistant_content if block["type"] == "text"), "")

                return _resp(200, {
                  "response": text_content,
                  "usage": response_body.get("usage", {}),
                  "conversation": messages + [{"role": "assistant", "content": assistant_content}]
                })

              except Exception as e:
                print(f"Chat error: {str(e)}")
                return _resp(500, {"error": "chat_error", "message": str(e)})

            parts = [p for p in path.split("/") if p]

            if not parts:
              return _resp(200, {
                "name": "Silvermoat MVP",
                "endpoints": ["/quote", "/policy", "/claim", "/payment", "/case", "/chat"]
              })

            domain = parts[0]
            if domain not in T:
              return _resp(404, {"error": "unknown_domain", "domain": domain})

            table = T[domain]
            body = {}
            if event.get("body"):
              try:
                body = json.loads(event["body"])
              except Exception:
                body = {"raw": event["body"]}

            # GET /{domain} -> list all items
            if method == "GET" and len(parts) == 1:
              response = table.scan()
              items = response.get("Items", [])
              # Sort by createdAt descending (most recent first)
              items.sort(key=lambda x: x.get("createdAt", 0), reverse=True)
              return _resp(200, {"items": items, "count": len(items)})

            # POST /{domain} -> create
            if method == "POST" and len(parts) == 1:
              _id = str(uuid.uuid4())
              # Convert floats to Decimal for DynamoDB compatibility
              clean_body = convert_floats_to_decimal(body)

              # Add default status based on domain type
              default_status = {
                "quote": "PENDING",
                "policy": "ACTIVE",
                "claim": "PENDING",
                "payment": "PENDING",
                "case": "OPEN"
              }.get(domain, "PENDING")

              item = {"id": _id, "createdAt": int(time.time()), "data": clean_body, "status": default_status}
              table.put_item(Item=item)
              _emit(f"{domain}.created", {"id": _id, "data": clean_body, "status": default_status})
              return _resp(201, {"id": _id, "item": item})

            # GET /{domain}/{id} -> read
            if method == "GET" and len(parts) == 2:
              _id = parts[1]
              r = table.get_item(Key={"id": _id})
              if "Item" not in r:
                return _resp(404, {"error": "not_found", "id": _id})
              return _resp(200, r["Item"])

            # POST /claim/{id}/status -> simple state update demo
            if domain == "claim" and method == "POST" and len(parts) == 3 and parts[2] == "status":
              _id = parts[1]
              new_status = (body.get("status") or "REVIEW").upper()
              table.update_item(
                Key={"id": _id},
                UpdateExpression="SET #s = :s, updatedAt = :u",
                ExpressionAttributeNames={"#s": "status"},
                ExpressionAttributeValues={":s": new_status, ":u": int(time.time())},
              )
              _emit("claim.status_changed", {"id": _id, "status": new_status})
              return _resp(200, {"id": _id, "status": new_status})

            # POST /claim/{id}/doc -> attach a tiny doc to S3 (demo)
            if domain == "claim" and method == "POST" and len(parts) == 3 and parts[2] == "doc":
              _id = parts[1]
              key = f"claims/{_id}/note.txt"
              content = (body.get("text") or "Demo claim note").encode("utf-8")
              s3.put_object(
                Bucket=DOCS_BUCKET,
                Key=key,
                Body=content,
                ContentType="text/plain"
              )
              _emit("claim.document_added", {"id": _id, "s3Key": key})
              return _resp(200, {"id": _id, "s3Key": key})

            # DELETE /{domain}/{id} -> delete single item
            if method == "DELETE" and len(parts) == 2:
              _id = parts[1]
              table.delete_item(Key={"id": _id})
              _emit(f"{domain}.deleted", {"id": _id})
              return _resp(200, {"id": _id, "deleted": True})

            # DELETE /{domain} -> delete all items in domain (bulk clear)
            if method == "DELETE" and len(parts) == 1:
              response = table.scan()
              items = response.get("Items", [])
              deleted_count = 0
              for item in items:
                table.delete_item(Key={"id": item["id"]})
                deleted_count += 1
              _emit(f"{domain}.bulk_deleted", {"count": deleted_count})
              return _resp(200, {"deleted": deleted_count, "domain": domain})

            return _resp(400, {"error": "unsupported_operation", "path": event.get("path"), "method": method})

  # ----------------------------
  # API Gateway (REST proxy to Lambda)
  # ----------------------------
  Api:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub "${AppName}-${StageName}-api"
      EndpointConfiguration:
        Types: [REGIONAL]

  ApiRootMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref Api
      ResourceId: !GetAtt Api.RootResourceId
      HttpMethod: ANY
      AuthorizationType: NONE
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MvpServiceFunction.Arn}/invocations"

  ApiProxyResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref Api
      ParentId: !GetAtt Api.RootResourceId
      PathPart: "{proxy+}"

  ApiProxyMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref Api
      ResourceId: !Ref ApiProxyResource
      HttpMethod: ANY
      AuthorizationType: NONE
      RequestParameters:
        method.request.path.proxy: true
      Integration:
        Type: AWS_PROXY
        IntegrationHttpMethod: POST
        Uri: !Sub "arn:${AWS::Partition}:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${MvpServiceFunction.Arn}/invocations"

  ApiDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiRootMethod
      - ApiProxyMethod
    Properties:
      RestApiId: !Ref Api
      Description: !Sub "Deployment token: ${ApiDeploymentToken}"

  ApiStage:
    Type: AWS::ApiGateway::Stage
    Properties:
      RestApiId: !Ref Api
      DeploymentId: !Ref ApiDeployment
      StageName: !Ref StageName

  ApiInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: "lambda:InvokeFunction"
      FunctionName: !Ref MvpServiceFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:${AWS::Partition}:execute-api:${AWS::Region}:${AWS::AccountId}:${Api}/*/*/*"

  # ----------------------------
  # Seeder Lambda (Custom Resource): seeds UI + demo data; cleans on delete
  # ----------------------------
  SeederLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal: { Service: lambda.amazonaws.com }
            Action: "sts:AssumeRole"
      Policies:
        - PolicyName: !Sub "${AppName}-${StageName}-seeder-policy"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: Logs
                Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"

              - Sid: S3ListBuckets
                Effect: Allow
                Action:
                  - "s3:ListBucket"
                  - "s3:ListBucketVersions"
                Resource:
                  - !GetAtt UiBucket.Arn
                  - !GetAtt DocsBucket.Arn

              - Sid: S3Objects
                Effect: Allow
                Action:
                  - "s3:PutObject"
                  - "s3:GetObject"
                  - "s3:DeleteObject"
                  - "s3:DeleteObjectVersion"
                Resource:
                  - !Sub "${UiBucket.Arn}/*"
                  - !Sub "${DocsBucket.Arn}/*"

              - Sid: DynamoSeedAndCleanup
                Effect: Allow
                Action:
                  - "dynamodb:PutItem"
                  - "dynamodb:Scan"
                  - "dynamodb:DeleteItem"
                Resource:
                  - !GetAtt QuotesTable.Arn
                  - !GetAtt PoliciesTable.Arn
                  - !GetAtt ClaimsTable.Arn
                  - !GetAtt PaymentsTable.Arn
                  - !GetAtt CasesTable.Arn

  SeederFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.12
      Handler: index.handler
      Role: !GetAtt SeederLambdaRole.Arn
      Timeout: 120
      MemorySize: 256
      Environment:
        Variables:
          UI_BUCKET: !Ref UiBucket
          DOCS_BUCKET: !Ref DocsBucket
          QUOTES_TABLE: !Ref QuotesTable
          POLICIES_TABLE: !Ref PoliciesTable
          CLAIMS_TABLE: !Ref ClaimsTable
          PAYMENTS_TABLE: !Ref PaymentsTable
          CASES_TABLE: !Ref CasesTable
          API_BASE: !Sub "https://${Api}.execute-api.${AWS::Region}.amazonaws.com/${StageName}"
          WEB_BASE: !GetAtt UiBucket.WebsiteURL
      Code:
        ZipFile: |
          import os, json, boto3, urllib.request, urllib.error

          s3 = boto3.client("s3")
          ddb = boto3.resource("dynamodb")

          def send(event, status, data, phys_id, reason=None):
            if reason is None:
              reason = "See CloudWatch logs for details"

            response_body = {
              "Status": status,
              "Reason": reason,
              "PhysicalResourceId": phys_id,
              "StackId": event["StackId"],
              "RequestId": event["RequestId"],
              "LogicalResourceId": event["LogicalResourceId"],
              "Data": data,
            }

            body = json.dumps(response_body).encode("utf-8")
            response_url = event.get("ResponseURL")

            if not response_url:
              raise ValueError("ResponseURL is missing from event")

            print(f"Sending {status} response to CloudFormation")
            print(f"ResponseURL: {response_url[:100]}...")  # Log partial URL for security

            req = urllib.request.Request(
              response_url,
              data=body,
              method="PUT",
              headers={
                "content-type": "",
                "content-length": str(len(body)),
              },
            )

            try:
              with urllib.request.urlopen(req, timeout=30) as response:
                response_code = response.getcode()
                print(f"Response sent successfully. HTTP {response_code}")
                if response_code != 200:
                  print(f"Warning: Expected 200, got {response_code}")
            except urllib.error.HTTPError as e:
              error_msg = f"HTTP error sending response: {e.code} {e.reason}"
              print(error_msg)
              try:
                error_body = e.read().decode("utf-8")
                print(f"Error response body: {error_body}")
              except Exception:
                pass
              raise Exception(f"Could not send response to CloudFormation: {error_msg}")
            except Exception as e:
              error_msg = f"Failed to send response: {type(e).__name__}: {str(e)}"
              print(error_msg)
              print(f"Body length: {len(body)}")
              print(f"Response body preview: {body[:200]}")
              raise Exception(f"Could not send response to CloudFormation: {error_msg}")

          def empty_bucket(bucket):
            print(f"Emptying bucket: {bucket}")
            deleted_count = 0
            
            # Delete all object versions + delete markers (works for versioned and non-versioned buckets)
            try:
              paginator = s3.get_paginator("list_object_versions")
              for page in paginator.paginate(Bucket=bucket):
                to_delete = []

                for v in page.get("Versions", []):
                  to_delete.append({"Key": v["Key"], "VersionId": v["VersionId"]})

                for m in page.get("DeleteMarkers", []):
                  to_delete.append({"Key": m["Key"], "VersionId": m["VersionId"]})

                if to_delete:
                  for i in range(0, len(to_delete), 1000):
                    batch = to_delete[i : i + 1000]
                    s3.delete_objects(Bucket=bucket, Delete={"Objects": batch})
                    deleted_count += len(batch)
                    print(f"Deleted {len(batch)} object versions/markers from {bucket}")
            except s3.exceptions.NoSuchBucket:
              print(f"Bucket {bucket} does not exist, skipping")
              return
            except Exception as e:
              # If bucket is not versioned or API is restricted, fall back to non-versioned deletion
              error_name = type(e).__name__
              if "NoSuchBucket" in error_name or "404" in str(e):
                print(f"Bucket {bucket} does not exist, skipping")
                return
              print(f"list_object_versions failed or not applicable for {bucket}: {error_name}: {e}")

            # Delete current objects (covers non-versioned and any remaining current keys)
            token = None
            while True:
              kwargs = {"Bucket": bucket}
              if token:
                kwargs["ContinuationToken"] = token
              try:
                r = s3.list_objects_v2(**kwargs)
                objs = [{"Key": o["Key"]} for o in r.get("Contents", [])]
                if objs:
                  for i in range(0, len(objs), 1000):
                    batch = objs[i : i + 1000]
                    s3.delete_objects(Bucket=bucket, Delete={"Objects": batch})
                    deleted_count += len(batch)
                    print(f"Deleted {len(batch)} objects from {bucket}")
                if r.get("IsTruncated"):
                  token = r.get("NextContinuationToken")
                else:
                  break
              except s3.exceptions.NoSuchBucket:
                print(f"Bucket {bucket} does not exist, skipping")
                return
              except Exception as e:
                error_name = type(e).__name__
                if "NoSuchBucket" in error_name or "404" in str(e):
                  print(f"Bucket {bucket} does not exist, skipping")
                  return
                raise
            
            if deleted_count == 0:
              print(f"Bucket {bucket} was already empty")
            else:
              print(f"Bucket {bucket} emptied successfully ({deleted_count} items deleted)")

          def wipe_table(name):
            t = ddb.Table(name)
            start_key = None
            while True:
              kwargs = {"ProjectionExpression": "id"}
              if start_key:
                kwargs["ExclusiveStartKey"] = start_key
              r = t.scan(**kwargs)
              for it in r.get("Items", []):
                t.delete_item(Key={"id": it["id"]})
              start_key = r.get("LastEvaluatedKey")
              if not start_key:
                break

          def handler(event, context):
            print(f"Custom Resource Handler invoked. RequestType: {event.get('RequestType')}")
            print(f"Event keys: {list(event.keys())}")

            props = event.get("ResourceProperties", {})
            mode = props.get("Mode", "seed")
            request_type = event.get("RequestType", "Create")

            print(f"Mode: {mode}")
            print(f"Processing RequestType: {request_type}, Mode: {mode}")

            phys_id = f"silvermoat-{mode}-{event.get('StackId','').split('/')[-1]}"

            try:
              ui_bucket = os.environ["UI_BUCKET"]
              docs_bucket = os.environ["DOCS_BUCKET"]
              tables = [
                os.environ["QUOTES_TABLE"],
                os.environ["POLICIES_TABLE"],
                os.environ["CLAIMS_TABLE"],
                os.environ["PAYMENTS_TABLE"],
                os.environ["CASES_TABLE"],
              ]
              api = os.environ.get("API_BASE", "")
              web = os.environ.get("WEB_BASE", "")

              print(f"UI_BUCKET: {ui_bucket}")
              print(f"DOCS_BUCKET: {docs_bucket}")
              print(f"API_BASE: {api}")
              print(f"WEB_BASE: {web}")

              # -------------------------
              # Cleanup mode
              # -------------------------
              if mode == "cleanup":
                if request_type == "Delete":
                  print("Starting cleanup...")
                  for tn in tables:
                    print(f"Wiping table: {tn}")
                    wipe_table(tn)

                  print(f"Emptying bucket: {ui_bucket}")
                  empty_bucket(ui_bucket)

                  print(f"Emptying bucket: {docs_bucket}")
                  empty_bucket(docs_bucket)

                  send(event, "SUCCESS", {"message": "cleaned"}, phys_id, "Cleanup completed successfully")
                else:
                  # Create/Update: no-op
                  print("Cleanup mode: Create/Update - no action needed")
                  send(event, "SUCCESS", {"message": "cleanup resource ready"}, phys_id, "Cleanup resource initialized")
                return

              # -------------------------
              # Seed mode
              # -------------------------
              if mode == "seed":
                if request_type == "Delete":
                  # Delete: no-op (cleanup is handled by CleanupCustomResource)
                  print("Seed mode: Delete - no action needed")
                  send(event, "SUCCESS", {"message": "seed resource deleted"}, phys_id, "Seed resource deleted")
                  return

                if request_type in ["Create", "Update"]:
                  print("Starting seeding process...")

                  # Seed UI (only if UiSeedingMode is "seeded")
                  ui_seeding_mode = props.get("UiSeedingMode", "seeded")
                  print(f"UiSeedingMode: {ui_seeding_mode}")
                  
                  if ui_seeding_mode == "seeded":
                    print(f"Uploading index.html to {ui_bucket}")
                    html = f"""<!doctype html>
                <html><head><meta charset=\"utf-8\"><title>Silvermoat Insurance Demo</title></head>
                <body style=\"font-family:Arial;padding:24px\">
                  <h1>Silvermoat Insurance</h1>
                  <p>One-shot CloudFormation MVP (S3 Website Hosting)</p>
                  <ul>
                    <li>API Base: <code>{api}</code></li>
                    <li>Web Base: <code>{web}</code></li>
                  </ul>
                  <button id=\"btn\">Create Quote</button>
                  <pre id=\"out\" style=\"margin-top:16px;background:#f7f7f7;padding:12px;border-radius:8px;\"></pre>
                  <script>
                    const out = document.getElementById(\"out\");
                    document.getElementById(\"btn\").onclick = async () => {{
                      const r = await fetch(\"{api}/quote\", {{
                        method:\"POST\",
                        headers:{{\"content-type\":\"application/json\"}},
                        body: JSON.stringify({{\"name\":\"Jane Doe\",\"zip\":\"33431\"}})
                      }});
                      out.textContent = await r.text();
                    }};
                  </script>
                </body></html>"""

                    s3.put_object(
                      Bucket=ui_bucket,
                      Key="index.html",
                      Body=html.encode("utf-8"),
                      ContentType="text/html",
                    )
                    print("index.html uploaded successfully")
                  else:
                    print(f"UiSeedingMode is '{ui_seeding_mode}' - skipping index.html upload (UI should be deployed externally)")

                  # Seed DynamoDB
                  print("Seeding DynamoDB tables with rich demo data...")

                  import time
                  from random import choice, randint, random

                  def put(table, item):
                    ddb.Table(table).put_item(Item=item)

                  # Helper functions for generating realistic data
                  def random_name():
                    firsts = ["John", "Jane", "Michael", "Sarah", "David", "Emily", "Robert", "Jessica", "William", "Jennifer", "James", "Linda", "Richard", "Patricia", "Joseph", "Mary", "Thomas", "Barbara", "Charles", "Elizabeth"]
                    lasts = ["Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis", "Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson", "Thomas", "Taylor", "Moore", "Jackson", "Martin"]
                    return f"{choice(firsts)} {choice(lasts)}"

                  def random_email(name):
                    domains = ["gmail.com", "yahoo.com", "outlook.com", "hotmail.com", "icloud.com"]
                    safe_name = name.lower().replace(" ", ".")
                    return f"{safe_name}{randint(1,999)}@{choice(domains)}"

                  def random_phone():
                    return f"{randint(200,999)}{randint(200,999)}{randint(1000,9999)}"

                  def random_address():
                    streets = ["Main St", "Oak Ave", "Maple Dr", "Park Blvd", "Lake Rd", "Hill Ct", "Pine St", "Cedar Ln", "Elm Dr", "Washington St"]
                    return f"{randint(100,9999)} {choice(streets)}"

                  def random_city_state():
                    cities = [
                      ("Miami", "FL"), ("Tampa", "FL"), ("Orlando", "FL"), ("Atlanta", "GA"), ("Charlotte", "NC"),
                      ("New York", "NY"), ("Los Angeles", "CA"), ("Chicago", "IL"), ("Houston", "TX"), ("Phoenix", "AZ"),
                      ("Philadelphia", "PA"), ("San Antonio", "TX"), ("San Diego", "CA"), ("Dallas", "TX"), ("Austin", "TX")
                    ]
                    return choice(cities)

                  def random_zip():
                    return f"{randint(10000,99999)}"

                  def random_dob():
                    year = randint(1950, 2000)
                    month = randint(1, 12)
                    day = randint(1, 28)
                    return f"{year}-{month:02d}-{day:02d}"

                  def random_date_recent(days_ago):
                    now = int(time.time())
                    return now - randint(0, days_ago * 86400)

                  def random_date_string(days_ago):
                    ts = random_date_recent(days_ago)
                    import datetime
                    dt = datetime.datetime.fromtimestamp(ts)
                    return dt.strftime("%Y-%m-%d")

                  def random_date_future(days_ahead):
                    now = int(time.time())
                    return now + randint(0, days_ahead * 86400)

                  def random_date_string_future(days_ahead):
                    ts = random_date_future(days_ahead)
                    import datetime
                    dt = datetime.datetime.fromtimestamp(ts)
                    return dt.strftime("%Y-%m-%d")

                  def random_currency(min_cents, max_cents):
                    return randint(min_cents, max_cents)

                  def random_vin():
                    chars = "ABCDEFGHJKLMNPRSTUVWXYZ0123456789"
                    return "".join(choice(chars) for _ in range(17))

                  # Generate 80 quotes
                  print("Generating 80 quotes...")
                  coverage_types = ["AUTO", "HOME", "LIFE", "HEALTH"]
                  quote_statuses = ["PENDING", "ACCEPTED", "DECLINED", "EXPIRED"]

                  for i in range(1, 81):
                    name = random_name()
                    coverage = choice(coverage_types) if random() < 0.4 else choice(coverage_types[1:]) if random() < 0.5 else choice(coverage_types[2:]) if random() < 0.67 else coverage_types[3]
                    city, state = random_city_state()
                    created = random_date_recent(3650)

                    quote = {
                      "id": f"q-{i:04d}",
                      "createdAt": created,
                      "data": {
                        "name": name,
                        "email": random_email(name),
                        "phone": random_phone(),
                        "address": random_address(),
                        "city": city,
                        "state": state,
                        "zip": random_zip(),
                        "dateOfBirth": random_dob(),
                        "premium_cents": random_currency(50000, 300000),
                        "coverageType": coverage,
                        "coverageLimit_cents": random_currency(10000000, 100000000),
                        "deductible_cents": choice([50000, 100000, 250000, 500000]),
                        "quoteNumber": f"Q-2024-{i:06d}",
                        "status": choice(quote_statuses) if random() < 0.25 else "PENDING",
                        "expiresAt": created + (10 * 86400)
                      }
                    }

                    if coverage == "AUTO":
                      makes = ["Honda", "Toyota", "Ford", "Chevrolet", "Nissan", "BMW", "Mercedes", "Audi", "Lexus", "Mazda"]
                      models = ["Civic", "Accord", "Camry", "Corolla", "F-150", "Silverado", "Altima", "Maxima", "3 Series", "C-Class"]
                      quote["data"]["vehicleInfo"] = {
                        "year": randint(2015, 2024),
                        "make": choice(makes),
                        "model": choice(models),
                        "vin": random_vin()
                      }

                    put(tables[0], quote)

                  print(f"Seeded {tables[0]} with 80 quotes")

                  # Generate 60 policies (75% of quotes accepted)
                  print("Generating 60 policies...")
                  policy_statuses = ["ACTIVE", "EXPIRED", "CANCELLED", "SUSPENDED"]
                  payment_schedules = ["MONTHLY", "QUARTERLY", "ANNUAL"]

                  policy_ids = []
                  for i in range(1, 61):
                    quote_id = f"q-{i:04d}"
                    created = random_date_recent(3650)
                    policy_id = f"p-{i:04d}"
                    policy_ids.append(policy_id)

                    policy = {
                      "id": policy_id,
                      "createdAt": created,
                      "data": {
                        "quoteId": quote_id,
                        "policyNumber": f"POL-2024-{i:06d}",
                        "status": choice(policy_statuses) if random() < 0.2 else "ACTIVE",
                        "holderName": random_name(),
                        "effectiveDate": random_date_string(3650),
                        "expiryDate": random_date_string_future(300),
                        "renewalDate": random_date_string_future(15),
                        "premium_cents": random_currency(100000, 400000),
                        "paymentSchedule": choice(payment_schedules),
                        "coverageLimit_cents": random_currency(25000000, 100000000),
                        "deductible_cents": choice([50000, 100000, 250000, 500000]),
                        "coverageType": choice(coverage_types),
                        "coverageDetails": {
                          "liability": random_currency(10000000, 50000000),
                          "collision": random_currency(25000000, 100000000),
                          "comprehensive": random_currency(25000000, 100000000)
                        }
                      }
                    }
                    put(tables[1], policy)

                  print(f"Seeded {tables[1]} with 60 policies")

                  # Generate 40 claims (67% of policies have claims)
                  print("Generating 40 claims...")
                  claim_statuses = ["INTAKE", "PENDING", "REVIEW", "APPROVED", "DENIED", "CLOSED"]
                  loss_types = ["AUTO_COLLISION", "AUTO_GLASS", "AUTO_THEFT", "PROPERTY_DAMAGE", "WATER_DAMAGE", "FIRE", "THEFT", "VANDALISM"]
                  adjuster_names = ["Bob Smith", "Alice Johnson", "Charlie Brown", "Diana Prince", "Eve Adams"]

                  for i in range(1, 41):
                    policy_id = choice(policy_ids)
                    created = random_date_recent(3650)
                    status_dist = random()
                    if status_dist < 0.3:
                      status = "INTAKE"
                    elif status_dist < 0.55:
                      status = "PENDING"
                    elif status_dist < 0.75:
                      status = "APPROVED"
                    elif status_dist < 0.9:
                      status = "REVIEW"
                    else:
                      status = "DENIED"

                    estimated = random_currency(10000, 5000000)
                    approved = int(estimated * (0.8 + random() * 0.2)) if status in ["APPROVED", "CLOSED"] else None

                    claim = {
                      "id": f"c-{i:04d}",
                      "createdAt": created,
                      "status": status,
                      "updatedAt": created + randint(3600, 86400 * 5),
                      "data": {
                        "policyId": policy_id,
                        "claimNumber": f"CLM-2024-{i:06d}",
                        "claimantName": random_name(),
                        "loss": f"{choice(loss_types).replace('_', ' ').title()} incident",
                        "lossType": choice(loss_types),
                        "incidentDate": random_date_string(3650),
                        "reportedDate": random_date_string(3650),
                        "estimatedAmount_cents": estimated,
                        "approvedAmount_cents": approved,
                        "deductible_cents": choice([0, 50000, 100000, 250000]),
                        "paidAmount_cents": approved if status == "CLOSED" and approved else None,
                        "description": f"Claim for {choice(loss_types).replace('_', ' ').lower()} with estimated damage",
                        "location": choice(["I-95 northbound", "I-75 southbound", "US-1", "Downtown", "Residential area", "Parking lot"]),
                        "adjusterName": choice(adjuster_names),
                        "adjusterNotes": "Under review" if status in ["PENDING", "REVIEW"] else "Claim processed"
                      }
                    }
                    put(tables[2], claim)

                  print(f"Seeded {tables[2]} with 40 claims")

                  # Generate 180 payments (~3 per policy)
                  print("Generating 180 payments...")
                  payment_statuses = ["PENDING", "COMPLETED", "FAILED", "REFUNDED"]
                  payment_methods = ["CREDIT_CARD", "ACH", "CHECK", "WIRE"]
                  payment_types = ["PREMIUM", "CLAIM", "REFUND"]

                  for i in range(1, 181):
                    policy_id = choice(policy_ids)
                    created = random_date_recent(3650)

                    payment = {
                      "id": f"pay-{i:04d}",
                      "createdAt": created,
                      "data": {
                        "policyId": policy_id,
                        "paymentNumber": f"PAY-2024-{i:06d}",
                        "amount_cents": random_currency(5000, 50000),
                        "status": choice(payment_statuses) if random() < 0.15 else "COMPLETED",
                        "paymentMethod": choice(payment_methods),
                        "paymentType": choice(payment_types) if random() < 0.1 else "PREMIUM",
                        "transactionId": f"txn_{randint(100000,999999)}",
                        "dueDate": random_date_string(3650),
                        "paidDate": random_date_string(3650) if random() < 0.85 else None,
                        "description": f"Payment for policy {policy_id}",
                        "lastFourDigits": f"{randint(1000,9999)}"
                      }
                    }
                    put(tables[3], payment)

                  print(f"Seeded {tables[3]} with 180 payments")

                  # Generate 50 cases
                  print("Generating 50 cases...")
                  case_topics = ["POLICY_CHANGE", "CLAIM_INQUIRY", "BILLING", "COMPLAINT", "COVERAGE_QUESTION", "CANCELLATION"]
                  case_statuses = ["OPEN", "IN_PROGRESS", "RESOLVED", "CLOSED"]
                  priorities = ["LOW", "MEDIUM", "HIGH", "URGENT"]
                  assignees = ["Alice Johnson", "Bob Smith", "Charlie Brown", "Diana Prince", "Eve Adams", "Frank Miller"]
                  departments = ["CUSTOMER_SERVICE", "CLAIMS", "BILLING", "UNDERWRITING"]

                  for i in range(1, 51):
                    created = random_date_recent(3650)

                    case = {
                      "id": f"case-{i:04d}",
                      "createdAt": created,
                      "data": {
                        "caseNumber": f"CS-2024-{i:06d}",
                        "title": f"{choice(case_topics).replace('_', ' ').title()} - Case {i}",
                        "topic": choice(case_topics),
                        "status": choice(case_statuses) if random() < 0.4 else "OPEN",
                        "priority": choice(priorities) if random() < 0.3 else "MEDIUM",
                        "assignee": choice(assignees),
                        "department": choice(departments),
                        "customerName": random_name(),
                        "policyId": choice(policy_ids) if random() < 0.7 else None,
                        "description": f"Customer inquiry regarding {choice(case_topics).replace('_', ' ').lower()}",
                        "resolution": None,
                        "dueDate": random_date_string_future(10),
                        "resolvedDate": random_date_string(3650) if random() < 0.3 else None
                      }
                    }
                    put(tables[4], case)

                  print(f"Seeded {tables[4]} with 50 cases")

                  # Seed one doc
                  print(f"Uploading sample doc to {docs_bucket}")
                  s3.put_object(
                    Bucket=docs_bucket,
                    Key="docs/sample.txt",
                    Body=b"Silvermoat demo document",
                    ContentType="text/plain",
                  )
                  print("Sample doc uploaded successfully")

                  print("Seeding completed successfully")
                  send(event, "SUCCESS", {"web": web, "api": api}, phys_id, "Seeding completed successfully")
                  return

                raise ValueError(f"Unknown RequestType in seed mode: {request_type}")

              raise ValueError(f"Unknown Mode: {mode}")

            except Exception as e:
              error_msg = f"Error in Custom Resource handler: {str(e)}"
              print(error_msg)
              import traceback
              print(traceback.format_exc())
              try:
                send(event, "FAILED", {"error": str(e)}, phys_id, error_msg)
              except Exception as send_error:
                print(f"CRITICAL: Failed to send FAILED response: {send_error}")
                raise

  SeedCustomResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - ApiStage
      - UiBucket
      - DocsBucket
      - UiBucketPolicy
    Properties:
      ServiceToken: !GetAtt SeederFunction.Arn
      Mode: seed
      UiSeedingMode: !Ref UiSeedingMode

  CleanupCustomResource:
    Type: AWS::CloudFormation::CustomResource
    DependsOn:
      - UiBucket
      - DocsBucket
      - SeederFunction
    Properties:
      ServiceToken: !GetAtt SeederFunction.Arn
      Mode: cleanup

Outputs:
  WebUrl:
    Description: "S3 Website URL (HTTP) - Use CloudFrontUrl for production, or this for test stacks"
    Value: !GetAtt UiBucket.WebsiteURL

  CloudFrontUrl:
    Condition: ShouldCreateCloudFront
    Description: "CloudFront distribution URL (HTTPS) - Primary access method"
    Value: !Sub "https://${UiDistribution.DomainName}"
    Export:
      Name: !Sub "${AWS::StackName}-CloudFrontUrl"

  CloudFrontDomain:
    Condition: ShouldCreateCloudFront
    Description: "CloudFront domain name (for DNS CNAME record)"
    Value: !GetAtt UiDistribution.DomainName
    Export:
      Name: !Sub "${AWS::StackName}-CloudFrontDomain"

  CustomDomainUrl:
    Condition: ShouldCreateCertificate
    Description: "Custom domain URL (if DomainName parameter provided and CloudFront enabled)"
    Value: !Sub "https://${DomainName}"

  CertificateArn:
    Condition: ShouldCreateCertificate
    Description: "ACM certificate ARN (for reference)"
    Value: !Ref UiCertificate

  ApiBaseUrl:
    Description: "API base URL (HTTPS)"
    Value: !Sub "https://${Api}.execute-api.${AWS::Region}.amazonaws.com/${StageName}"

  UiBucketName:
    Value: !Ref UiBucket

  DocsBucketName:
    Value: !Ref DocsBucket

  QuotesTableName:
    Value: !Ref QuotesTable
  PoliciesTableName:
    Value: !Ref PoliciesTable
  ClaimsTableName:
    Value: !Ref ClaimsTable
  PaymentsTableName:
    Value: !Ref PaymentsTable
  CasesTableName:
    Value: !Ref CasesTable

  DemoNotificationsTopicArn:
    Value: !Ref DemoNotificationsTopic